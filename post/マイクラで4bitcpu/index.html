<!doctype html><html lang=ja-jp><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=theme-color content="#494f5c"><meta name=msapplication-TileColor content="#494f5c"><meta itemprop=name content="マイクラで4bitCPU"><meta itemprop=description content="この記事は、大阪工業大学 Advent Calendar 2020の16日目の記事です。
はじめに マインクラフトで4bitCPUを作りました。
実行できる命令はLDIとADDの2種類、レジスタは2個、命令メモリは8個、動作周波数は約0.5Hzです。扱える値は符号なし整数です。レジスタ幅が4bitでLDIのオペランドが2bitの即値を取ることが出来るので0~15（\(2^4\)）の範囲で0~3(\(2^2\))の加算を行うことが出来ます。
  4bitCPU
  4bitCPU CPU 原始的なCPUは以下の部品で作ることが出来ます。
 命令メモリ プログラムカウンタ 全加算器 レジスタファイル ALU（AND、SUB、OR、ADDとかの演算が出来る） セレクタ 符号拡張機  CPUは命令が格納された命令メモリから順番に命令を読み込み、命令を解釈して様々な処理をを行います。一般にCPUでの演算は汎用レジスタ同士で行われます。これはレジスタへのアクセス速度がメモリへのアクセスに比べて非常に早いためです。
今日よく使われているIntelやAMDのx86-64アーキテクチャでは汎用レジスタは16個搭載されています。今回作成した4bitCPUでは汎用レジスタは2つです。
命令セット 命令を作成するために各bitをどのように使うかを決定します。
今回作成した4bitCPUは命令長が4bitです。そのため、今回の設計ではオペランドに1bit、レジスタに1bit割り振りました。よって命令と汎用レジスタ数はそれぞれ2個（\(2^1\)）ずつとなっています。使用出来る命令はADDとLDIです。
   命令 命令機能     ADD Rdest Rdest <- R0 + R1   LDI Rdest, imm2 Rdest <- imm2    ADD命令はレジスタ同士を加算し、レジスタに書き戻します。オペコードは0で、オペランドに書き込み先レジスタ（Rdest）を指定します。普通のCPUであればRdestだけでなくRsrcも指定しますが今回はレジスタが2つしかないので省略しています。
LDI命令は1~3の整数値をレジスタに書き込みます。オペコードが1でオペランドに書き込み先レジスタ（Rdest）と即値を取ります。即値は2bitなので1~3を指定することが出来ます。
   命令 バイナリ表記     ADD R0 0 0 X X   LDI R1, 2 1 1 1 0    命令の表記例です。Xは未使用を表します。"><meta itemprop=datePublished content="2020-12-14T18:19:34+09:00"><meta itemprop=dateModified content="2020-12-14T18:19:34+09:00"><meta itemprop=wordCount content="118"><meta itemprop=image content="https://aoken7.github.io/aokenIcon.jpeg"><meta itemprop=keywords content><meta property="og:title" content="マイクラで4bitCPU"><meta property="og:description" content="この記事は、大阪工業大学 Advent Calendar 2020の16日目の記事です。
はじめに マインクラフトで4bitCPUを作りました。
実行できる命令はLDIとADDの2種類、レジスタは2個、命令メモリは8個、動作周波数は約0.5Hzです。扱える値は符号なし整数です。レジスタ幅が4bitでLDIのオペランドが2bitの即値を取ることが出来るので0~15（\(2^4\)）の範囲で0~3(\(2^2\))の加算を行うことが出来ます。
  4bitCPU
  4bitCPU CPU 原始的なCPUは以下の部品で作ることが出来ます。
 命令メモリ プログラムカウンタ 全加算器 レジスタファイル ALU（AND、SUB、OR、ADDとかの演算が出来る） セレクタ 符号拡張機  CPUは命令が格納された命令メモリから順番に命令を読み込み、命令を解釈して様々な処理をを行います。一般にCPUでの演算は汎用レジスタ同士で行われます。これはレジスタへのアクセス速度がメモリへのアクセスに比べて非常に早いためです。
今日よく使われているIntelやAMDのx86-64アーキテクチャでは汎用レジスタは16個搭載されています。今回作成した4bitCPUでは汎用レジスタは2つです。
命令セット 命令を作成するために各bitをどのように使うかを決定します。
今回作成した4bitCPUは命令長が4bitです。そのため、今回の設計ではオペランドに1bit、レジスタに1bit割り振りました。よって命令と汎用レジスタ数はそれぞれ2個（\(2^1\)）ずつとなっています。使用出来る命令はADDとLDIです。
   命令 命令機能     ADD Rdest Rdest <- R0 + R1   LDI Rdest, imm2 Rdest <- imm2    ADD命令はレジスタ同士を加算し、レジスタに書き戻します。オペコードは0で、オペランドに書き込み先レジスタ（Rdest）を指定します。普通のCPUであればRdestだけでなくRsrcも指定しますが今回はレジスタが2つしかないので省略しています。
LDI命令は1~3の整数値をレジスタに書き込みます。オペコードが1でオペランドに書き込み先レジスタ（Rdest）と即値を取ります。即値は2bitなので1~3を指定することが出来ます。
   命令 バイナリ表記     ADD R0 0 0 X X   LDI R1, 2 1 1 1 0    命令の表記例です。Xは未使用を表します。"><meta property="og:type" content="article"><meta property="og:url" content="https://aoken7.github.io/post/%E3%83%9E%E3%82%A4%E3%82%AF%E3%83%A9%E3%81%A74bitcpu/"><meta property="og:image" content="https://aoken7.github.io/aokenIcon.jpeg"><meta property="article:published_time" content="2020-12-14T18:19:34+09:00"><meta property="article:modified_time" content="2020-12-14T18:19:34+09:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://aoken7.github.io/aokenIcon.jpeg"><meta name=twitter:title content="マイクラで4bitCPU"><meta name=twitter:description content="この記事は、大阪工業大学 Advent Calendar 2020の16日目の記事です。
はじめに マインクラフトで4bitCPUを作りました。
実行できる命令はLDIとADDの2種類、レジスタは2個、命令メモリは8個、動作周波数は約0.5Hzです。扱える値は符号なし整数です。レジスタ幅が4bitでLDIのオペランドが2bitの即値を取ることが出来るので0~15（\(2^4\)）の範囲で0~3(\(2^2\))の加算を行うことが出来ます。
  4bitCPU
  4bitCPU CPU 原始的なCPUは以下の部品で作ることが出来ます。
 命令メモリ プログラムカウンタ 全加算器 レジスタファイル ALU（AND、SUB、OR、ADDとかの演算が出来る） セレクタ 符号拡張機  CPUは命令が格納された命令メモリから順番に命令を読み込み、命令を解釈して様々な処理をを行います。一般にCPUでの演算は汎用レジスタ同士で行われます。これはレジスタへのアクセス速度がメモリへのアクセスに比べて非常に早いためです。
今日よく使われているIntelやAMDのx86-64アーキテクチャでは汎用レジスタは16個搭載されています。今回作成した4bitCPUでは汎用レジスタは2つです。
命令セット 命令を作成するために各bitをどのように使うかを決定します。
今回作成した4bitCPUは命令長が4bitです。そのため、今回の設計ではオペランドに1bit、レジスタに1bit割り振りました。よって命令と汎用レジスタ数はそれぞれ2個（\(2^1\)）ずつとなっています。使用出来る命令はADDとLDIです。
   命令 命令機能     ADD Rdest Rdest <- R0 + R1   LDI Rdest, imm2 Rdest <- imm2    ADD命令はレジスタ同士を加算し、レジスタに書き戻します。オペコードは0で、オペランドに書き込み先レジスタ（Rdest）を指定します。普通のCPUであればRdestだけでなくRsrcも指定しますが今回はレジスタが2つしかないので省略しています。
LDI命令は1~3の整数値をレジスタに書き込みます。オペコードが1でオペランドに書き込み先レジスタ（Rdest）と即値を取ります。即値は2bitなので1~3を指定することが出来ます。
   命令 バイナリ表記     ADD R0 0 0 X X   LDI R1, 2 1 1 1 0    命令の表記例です。Xは未使用を表します。"><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color><link rel="shortcut icon" href=/favicon.ico><title>マイクラで4bitCPU</title><link rel=stylesheet href=https://aoken7.github.io/css/style.min.e396dce9bec94b9b18a11527bc37495a8a7b3e1af44c692d40a660c48b373c3b.css integrity="sha256-45bc6b7JS5sYoRUnvDdJWop7Phr0TGktQKZgxIs3PDs=" crossorigin=anonymous><link rel=stylesheet href=https://aoken7.github.io/css/custom.css><meta property="og:title" content="マイクラで4bitCPU"><meta property="og:description" content="この記事は、大阪工業大学 Advent Calendar 2020の16日目の記事です。
はじめに マインクラフトで4bitCPUを作りました。
実行できる命令はLDIとADDの2種類、レジスタは2個、命令メモリは8個、動作周波数は約0.5Hzです。扱える値は符号なし整数です。レジスタ幅が4bitでLDIのオペランドが2bitの即値を取ることが出来るので0~15（\(2^4\)）の範囲で0~3(\(2^2\))の加算を行うことが出来ます。
  4bitCPU
  4bitCPU CPU 原始的なCPUは以下の部品で作ることが出来ます。
 命令メモリ プログラムカウンタ 全加算器 レジスタファイル ALU（AND、SUB、OR、ADDとかの演算が出来る） セレクタ 符号拡張機  CPUは命令が格納された命令メモリから順番に命令を読み込み、命令を解釈して様々な処理をを行います。一般にCPUでの演算は汎用レジスタ同士で行われます。これはレジスタへのアクセス速度がメモリへのアクセスに比べて非常に早いためです。
今日よく使われているIntelやAMDのx86-64アーキテクチャでは汎用レジスタは16個搭載されています。今回作成した4bitCPUでは汎用レジスタは2つです。
命令セット 命令を作成するために各bitをどのように使うかを決定します。
今回作成した4bitCPUは命令長が4bitです。そのため、今回の設計ではオペランドに1bit、レジスタに1bit割り振りました。よって命令と汎用レジスタ数はそれぞれ2個（\(2^1\)）ずつとなっています。使用出来る命令はADDとLDIです。
   命令 命令機能     ADD Rdest Rdest <- R0 + R1   LDI Rdest, imm2 Rdest <- imm2    ADD命令はレジスタ同士を加算し、レジスタに書き戻します。オペコードは0で、オペランドに書き込み先レジスタ（Rdest）を指定します。普通のCPUであればRdestだけでなくRsrcも指定しますが今回はレジスタが2つしかないので省略しています。
LDI命令は1~3の整数値をレジスタに書き込みます。オペコードが1でオペランドに書き込み先レジスタ（Rdest）と即値を取ります。即値は2bitなので1~3を指定することが出来ます。
   命令 バイナリ表記     ADD R0 0 0 X X   LDI R1, 2 1 1 1 0    命令の表記例です。Xは未使用を表します。"><meta property="og:type" content="article"><meta property="og:url" content="https://aoken7.github.io/post/%E3%83%9E%E3%82%A4%E3%82%AF%E3%83%A9%E3%81%A74bitcpu/"><meta property="og:image" content="https://aoken7.github.io/aokenIcon.jpeg"><meta property="article:published_time" content="2020-12-14T18:19:34+09:00"><meta property="article:modified_time" content="2020-12-14T18:19:34+09:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://aoken7.github.io/aokenIcon.jpeg"><meta name=twitter:title content="マイクラで4bitCPU"><meta name=twitter:description content="この記事は、大阪工業大学 Advent Calendar 2020の16日目の記事です。
はじめに マインクラフトで4bitCPUを作りました。
実行できる命令はLDIとADDの2種類、レジスタは2個、命令メモリは8個、動作周波数は約0.5Hzです。扱える値は符号なし整数です。レジスタ幅が4bitでLDIのオペランドが2bitの即値を取ることが出来るので0~15（\(2^4\)）の範囲で0~3(\(2^2\))の加算を行うことが出来ます。
  4bitCPU
  4bitCPU CPU 原始的なCPUは以下の部品で作ることが出来ます。
 命令メモリ プログラムカウンタ 全加算器 レジスタファイル ALU（AND、SUB、OR、ADDとかの演算が出来る） セレクタ 符号拡張機  CPUは命令が格納された命令メモリから順番に命令を読み込み、命令を解釈して様々な処理をを行います。一般にCPUでの演算は汎用レジスタ同士で行われます。これはレジスタへのアクセス速度がメモリへのアクセスに比べて非常に早いためです。
今日よく使われているIntelやAMDのx86-64アーキテクチャでは汎用レジスタは16個搭載されています。今回作成した4bitCPUでは汎用レジスタは2つです。
命令セット 命令を作成するために各bitをどのように使うかを決定します。
今回作成した4bitCPUは命令長が4bitです。そのため、今回の設計ではオペランドに1bit、レジスタに1bit割り振りました。よって命令と汎用レジスタ数はそれぞれ2個（\(2^1\)）ずつとなっています。使用出来る命令はADDとLDIです。
   命令 命令機能     ADD Rdest Rdest <- R0 + R1   LDI Rdest, imm2 Rdest <- imm2    ADD命令はレジスタ同士を加算し、レジスタに書き戻します。オペコードは0で、オペランドに書き込み先レジスタ（Rdest）を指定します。普通のCPUであればRdestだけでなくRsrcも指定しますが今回はレジスタが2つしかないので省略しています。
LDI命令は1~3の整数値をレジスタに書き込みます。オペコードが1でオペランドに書き込み先レジスタ（Rdest）と即値を取ります。即値は2bitなので1~3を指定することが出来ます。
   命令 バイナリ表記     ADD R0 0 0 X X   LDI R1, 2 1 1 1 0    命令の表記例です。Xは未使用を表します。"></head><body id=page><header id=site-header class="animated slideInUp"><div class="hdr-wrapper section-inner"><div class=hdr-left><div class=site-branding><a href=https://aoken7.github.io/>Incomplete</a></div><nav class="site-nav hide-in-mobile"><a href=https://aoken7.github.io/about/>About</a>
<a href=https://aoken7.github.io/posts/>Posts</a>
<a href=https://aoken7.github.io/products/>Products</a></nav></div><div class="hdr-right hdr-icons"><span class="hdr-social hide-in-mobile"><a href=https://twitter.com/_aoken target=_blank rel="noopener me" title=Twitter><svg xmlns="http://www.w3.org/2000/svg" class="feather" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M23 3a10.9 10.9.0 01-3.14 1.53 4.48 4.48.0 00-7.86 3v1A10.66 10.66.0 013 4s-4 9 5 13a11.64 11.64.0 01-7 2c9 5 20 0 20-11.5a4.5 4.5.0 00-.08-.83A7.72 7.72.0 0023 3z"/></svg></a><a href=https://github.com/aoken7 target=_blank rel="noopener me" title=Github><svg xmlns="http://www.w3.org/2000/svg" class="feather" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77a5.44 5.44.0 00-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a><a href=https://atcoder.jp/users/aoken_7 target=_blank rel="noopener me" title=Atcoder><svg xmlns="http://www.w3.org/2000/svg" class="feather feather-link" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 007.54.54l3-3a5 5 0 00-7.07-7.07l-1.72 1.71"/><path d="M14 11a5 5 0 00-7.54-.54l-3 3a5 5 0 007.07 7.07l1.71-1.71"/></svg></a></span><button id=menu-btn class=hdr-btn><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="18" x2="21" y2="18"/></svg></button></div></div></header><div id=mobile-menu class="animated fast"><ul><li><a href=https://aoken7.github.io/about/>About</a></li><li><a href=https://aoken7.github.io/posts/>Posts</a></li><li><a href=https://aoken7.github.io/products/>Products</a></li></ul></div><main class="site-main section-inner thin animated fadeIn faster"><h1>マイクラで4bitCPU</h1><div class=content><p>この記事は、大阪工業大学 <a href=https://adventar.org/calendars/5332>Advent Calendar</a> 2020の16日目の記事です。</p><h1 id=はじめに>はじめに<a href=#はじめに class=anchor aria-hidden=true><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h1><p>マインクラフトで4bitCPUを作りました。<br>実行できる命令は<em>LDI</em>と<em>ADD</em>の2種類、レジスタは2個、命令メモリは8個、動作周波数は約0.5Hzです。扱える値は符号なし整数です。レジスタ幅が4bitで<em>LDI</em>のオペランドが2bitの即値を取ることが出来るので0~15（\(2^4\)）の範囲で0~3(\(2^2\))の加算を行うことが出来ます。</p><figure><img src=/images/4bitcpu/cpu0.png alt=image><figcaption><p>4bitCPU</p></figcaption></figure><h1 id=4bitcpu>4bitCPU<a href=#4bitcpu class=anchor aria-hidden=true><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h1><h2 id=cpu>CPU<a href=#cpu class=anchor aria-hidden=true><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h2><p>原始的なCPUは以下の部品で作ることが出来ます。</p><ul><li>命令メモリ</li><li>プログラムカウンタ</li><li>全加算器</li><li>レジスタファイル</li><li>ALU（AND、SUB、OR、ADDとかの演算が出来る）</li><li>セレクタ</li><li>符号拡張機</li></ul><p>CPUは命令が格納された命令メモリから順番に命令を読み込み、命令を解釈して様々な処理をを行います。一般にCPUでの演算は汎用レジスタ同士で行われます。これはレジスタへのアクセス速度がメモリへのアクセスに比べて非常に早いためです。<br>今日よく使われているIntelやAMDのx86-64アーキテクチャでは汎用レジスタは16個搭載されています。今回作成した4bitCPUでは汎用レジスタは2つです。</p><h2 id=命令セット>命令セット<a href=#命令セット class=anchor aria-hidden=true><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h2><p>命令を作成するために各bitをどのように使うかを決定します。</p><p>今回作成した4bitCPUは命令長が4bitです。そのため、今回の設計ではオペランドに1bit、レジスタに1bit割り振りました。よって命令と汎用レジスタ数はそれぞれ2個（\(2^1\)）ずつとなっています。使用出来る命令はADDとLDIです。</p><table><thead><tr><th>命令</th><th>命令機能</th></tr></thead><tbody><tr><td>ADD Rdest</td><td>Rdest &lt;- R0 + R1</td></tr><tr><td>LDI Rdest, imm2</td><td>Rdest &lt;- imm2</td></tr></tbody></table><p>ADD命令はレジスタ同士を加算し、レジスタに書き戻します。オペコードは0で、オペランドに書き込み先レジスタ（Rdest）を指定します。普通のCPUであればRdestだけでなくRsrcも指定しますが今回はレジスタが2つしかないので省略しています。</p><p>LDI命令は1~3の整数値をレジスタに書き込みます。オペコードが1でオペランドに書き込み先レジスタ（Rdest）と即値を取ります。即値は2bitなので1~3を指定することが出来ます。</p><table><thead><tr><th>命令</th><th>バイナリ表記</th></tr></thead><tbody><tr><td>ADD R0</td><td>0 0 X X</td></tr><tr><td>LDI R1, 2</td><td>1 1 1 0</td></tr></tbody></table><p>命令の表記例です。Xは未使用を表します。</p><p>bitの割り振りとしてはオペコードを2bitにして即値を1bitにするほうが実行できる命令の数が増え、汎用性の高いCPUを作ることが出来ましたが実装を簡略化するために今回のような設計にしました。</p><h2 id=組み合わせ回路>組み合わせ回路<a href=#組み合わせ回路 class=anchor aria-hidden=true><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h2><p>CPUは沢山の<strong>組み合わせ回路</strong>で構成されます。組み合わせ回路とは<strong>AND回路</strong>や<strong>OR回路</strong>、<strong>NOT回路</strong>などや、これらを組み合わせて作ることが出来る回路のことです。
例えばAND回路、OR回路、NOT回路を組み合わせることで半加算器を作ることができ、半加算器2つとOR回路を組み合わせることで全加算器を作ることが出来ます。<br>マインクラフトにはレッドストーン回路と呼ばれるものがあります。これを用いることで組み合わせ回路を作ることが出来ます。
組み合わせ回路を作ることができればCPUを作ることが出来るわけです。</p><figure class=center><img src=/images/4bitcpu/AND.png alt=image width=500><figcaption><p>AND回路</p></figcaption></figure><figure class=center><img src=/images/4bitcpu/OR.png alt=image width=500><figcaption><p>OR回路</p></figcaption></figure><h2 id=回路>回路<a href=#回路 class=anchor aria-hidden=true><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h2><p>先ほど決めた命令にしたがって計算できるように回路を作成します。</p><p>回路の実装は以下のようになりました。
先ほど説明した原始的なCPUと異なる点として、実装を簡単にするためにプログラムカウンタの代わりにシフトレジスタを使いました。また命令が2つしかないのでALUの代わりに全加算器を用い、セレクタで命令を判定しています。 配線は白がクロック、赤がリセットです。命令メモリにはレバーで命令を手打ちします。</p><p>回路はクロックに同期して命令メモリの命令を順番に実行します。黄色い枠のセレクタは命令のオペランドで書き込む値の選択を行い、水色の枠のセレクタは書き込み先レジスタを選択します。</p><figure class=center><img src=/images/4bitcpu/kairo.png alt=image><figcaption><p>4bitCPU</p></figcaption></figure><p>さいごに実際に計算を行います。</p><table><thead><tr><th>命令</th><th>バイナリ表記</th><th>R0（予測値）</th><th>R1（予測値）</th></tr></thead><tbody><tr><td>LDI R0, 01</td><td>1001</td><td>0001</td><td>0000</td></tr><tr><td>LDI R1, 10</td><td>1110</td><td>0001</td><td>0010</td></tr><tr><td>ADD R0</td><td>00XX</td><td>0011</td><td>0010</td></tr><tr><td>LDI R2, 11</td><td>1111</td><td>0011</td><td>0011</td></tr><tr><td>ADD R0</td><td>00XX</td><td>0110</td><td>0011</td></tr><tr><td>ADD R0</td><td>00XX</td><td>1001</td><td>0011</td></tr></tbody></table><p>左の4つの明かりがR0、右の4つのあかりがR1です。明かりがついているときが1で消えているときが0に対応します。
正しく計算が行われていることがわかると思います。</p><figure class=center><img src=/images/4bitcpu/reg.gif alt=image><figcaption><p>register</p></figcaption></figure><h1 id=おわりに>おわりに<a href=#おわりに class=anchor aria-hidden=true><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h1><p>今回作成したCPUは非常に単純なものでしたが実際に計算を行うことが出来ました。回路の動作が目に見える形で実行され計算が行われるのは見ていて面白かったです。</p><p>CPUに興味の湧いた方や気になる方が入れば下記のサイト上で簡単なCPUが作れるみたいなので遊んでみるといいと思います。</p><ul><li><a href=http://nandgame.com/>http://nandgame.com/</a></li></ul><h1 id=参考記事>参考記事<a href=#参考記事 class=anchor aria-hidden=true><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 015 5 5 5 0 01-5 5h-3m-6 0H6a5 5 0 01-5-5 5 5 0 015-5h3"/><line x1="8" y1="12" x2="16" y2="12"/></svg></a></h1><ul><li><a href=https://w.atwiki.jp/minecraft/pages/26.html>https://w.atwiki.jp/minecraft/pages/26.html</a></li></ul></div></main><footer id=site-footer class="section-inner thin animated fadeIn faster"><script type=text/javascript src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><p>&copy; 2021 <a href=https://aoken7.github.io/>Aoken</a> &#183; <a href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank rel=noopener>CC BY-NC 4.0</a></p><p>Made with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> &#183; Theme <a href=https://github.com/Track3/hermit target=_blank rel=noopener>Hermit</a> &#183; <a href=https://aoken7.github.io/posts/index.xml target=_blank title=rss><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></p></footer><script src=https://aoken7.github.io/js/bundle.min.4a9a0ac3d2217822c7865b4161e6c2a71de1d70492264337755427898dd718f6.js integrity="sha256-SpoKw9IheCLHhltBYebCpx3h1wSSJkM3dVQniY3XGPY=" crossorigin=anonymous></script></body></html>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Aoken's Note</title><link>https://aoken7.github.io/posts/</link><description>Recent content in Posts on Aoken's Note</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Sun, 20 Dec 2020 00:04:50 +0900</lastBuildDate><atom:link href="https://aoken7.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>ABC186</title><link>https://aoken7.github.io/posts/abc186/</link><pubDate>Sun, 20 Dec 2020 00:04:50 +0900</pubDate><guid>https://aoken7.github.io/posts/abc186/</guid><description>A-Brick NをWで割るだけ。少数は切り捨てる。
B-Blocks_on_Grid 一番小さい値ですべての値を引いた合計が答え。
pythonでやると簡単にできそう。
C-Unlucky_7 c++ではstd::octを使うと8進数に変換出来るらしい。調べて知った。
1からNまで7を含むかを判定すればいい。
D-Sum_of_difference あらかじめAに関して累積和をとっておけばいい。
ソートすれば良いのに気づかずにだいぶ時間を使ってしまった。
E-Throne 解けなかった。 modだろうとは思ったけど解法が思いつかなかった。
一周ごとにあまりの値をsetで管理して、同じあまりが2度出たら永遠に巡回するので解なしとする実装をしたけど計算が爆発してしまった。（それはそう）
中国剰余定理名前しか知らなかったので要復習。
まとめ D問題をひと目見て貪欲だと判断出来たのでヨシ！
欲を言うともう少し早く解きたかった。
あとACLに含まれてるアルゴリズムは一通り勉強しようと思いましたん。</description><content type="html"><![CDATA[<h2 id="a-brick">A-Brick</h2>
<p>NをWで割るだけ。少数は切り捨てる。</p>
<h2 id="b-blocks_on_grid">B-Blocks_on_Grid</h2>
<p>一番小さい値ですべての値を引いた合計が答え。<br>
pythonでやると簡単にできそう。</p>
<h2 id="c-unlucky_7">C-Unlucky_7</h2>
<p>c++ではstd::octを使うと8進数に変換出来るらしい。調べて知った。<br>
1からNまで7を含むかを判定すればいい。</p>
<h2 id="d-sum_of_difference">D-Sum_of_difference</h2>
<p>あらかじめAに関して累積和をとっておけばいい。<br>
ソートすれば良いのに気づかずにだいぶ時間を使ってしまった。</p>
<h2 id="e-throne">E-Throne</h2>
<p>解けなかった。
modだろうとは思ったけど解法が思いつかなかった。<br>
一周ごとにあまりの値をsetで管理して、同じあまりが2度出たら永遠に巡回するので解なしとする実装をしたけど計算が爆発してしまった。（それはそう）<br>
中国剰余定理名前しか知らなかったので要復習。</p>
<h2 id="まとめ">まとめ</h2>
<p>D問題をひと目見て貪欲だと判断出来たのでヨシ！<br>
欲を言うともう少し早く解きたかった。<br>
あとACLに含まれてるアルゴリズムは一通り勉強しようと思いましたん。</p>
]]></content></item><item><title>マイクラで4bitCPU</title><link>https://aoken7.github.io/posts/%E3%83%9E%E3%82%A4%E3%82%AF%E3%83%A9%E3%81%A74bitcpu/</link><pubDate>Mon, 14 Dec 2020 18:19:34 +0900</pubDate><guid>https://aoken7.github.io/posts/%E3%83%9E%E3%82%A4%E3%82%AF%E3%83%A9%E3%81%A74bitcpu/</guid><description>この記事は、大阪工業大学 Advent Calendar 2020の16日目の記事です。
はじめに マインクラフトで4bitCPUを作りました。
実行できる命令はLDIとADDの2種類、レジスタは2個、命令メモリは8個、動作周波数は約0.5Hzです。扱える値は符号なし整数です。レジスタ幅が4bitでLDIのオペランドが2bitの即値を取ることが出来るので0~15（\(2^4\)）の範囲で0~3(\(2^2\))の加算を行うことが出来ます。
4bitCPU
4bitCPU CPU 原始的なCPUは以下の部品で作ることが出来ます。
命令メモリ プログラムカウンタ 全加算器 レジスタファイル ALU（AND、SUB、OR、ADDとかの演算が出来る） セレクタ 符号拡張機 CPUは命令が格納された命令メモリから順番に命令を読み込み、命令を解釈して様々な処理をを行います。一般にCPUでの演算は汎用レジスタ同士で行われます。これはレジスタへのアクセス速度がメモリへのアクセスに比べて非常に早いためです。
今日よく使われているIntelやAMDのx86-64アーキテクチャでは汎用レジスタは16個搭載されています。今回作成した4bitCPUでは汎用レジスタは2つです。
命令セット 命令を作成するために各bitをどのように使うかを決定します。
今回作成した4bitCPUは命令長が4bitです。そのため、今回の設計ではオペランドに1bit、レジスタに1bit割り振りました。よって命令と汎用レジスタ数はそれぞれ2個（\(2^1\)）ずつとなっています。使用出来る命令はADDとLDIです。
命令 命令機能 ADD Rdest Rdest &amp;lt;- R0 + R1 LDI Rdest, imm2 Rdest &amp;lt;- imm2 ADD命令はレジスタ同士を加算し、レジスタに書き戻します。オペコードは0で、オペランドに書き込み先レジスタ（Rdest）を指定します。普通のCPUであればRdestだけでなくRsrcも指定しますが今回はレジスタが2つしかないので省略しています。
LDI命令は1~3の整数値をレジスタに書き込みます。オペコードが1でオペランドに書き込み先レジスタ（Rdest）と即値を取ります。即値は2bitなので1~3を指定することが出来ます。
命令 バイナリ表記 ADD R0 0 0 X X LDI R1, 2 1 1 1 0 命令の表記例です。Xは未使用を表します。</description><content type="html"><![CDATA[<p>この記事は、大阪工業大学 <a href="https://adventar.org/calendars/5332">Advent Calendar</a> 2020の16日目の記事です。</p>
<h1 id="はじめに">はじめに</h1>
<p>マインクラフトで4bitCPUを作りました。<br>
実行できる命令は<em>LDI</em>と<em>ADD</em>の2種類、レジスタは2個、命令メモリは8個、動作周波数は約0.5Hzです。扱える値は符号なし整数です。レジスタ幅が4bitで<em>LDI</em>のオペランドが2bitの即値を取ることが出来るので0~15（\(2^4\)）の範囲で0~3(\(2^2\))の加算を行うことが出来ます。</p>
<figure>
    <img src="/images/4bitcpu/cpu0.png"
         alt="image"/> <figcaption>
            <p>4bitCPU</p>
        </figcaption>
</figure>

<h1 id="4bitcpu">4bitCPU</h1>
<h2 id="cpu">CPU</h2>
<p>原始的なCPUは以下の部品で作ることが出来ます。</p>
<ul>
<li>命令メモリ</li>
<li>プログラムカウンタ</li>
<li>全加算器</li>
<li>レジスタファイル</li>
<li>ALU（AND、SUB、OR、ADDとかの演算が出来る）</li>
<li>セレクタ</li>
<li>符号拡張機</li>
</ul>
<p>CPUは命令が格納された命令メモリから順番に命令を読み込み、命令を解釈して様々な処理をを行います。一般にCPUでの演算は汎用レジスタ同士で行われます。これはレジスタへのアクセス速度がメモリへのアクセスに比べて非常に早いためです。<br>
今日よく使われているIntelやAMDのx86-64アーキテクチャでは汎用レジスタは16個搭載されています。今回作成した4bitCPUでは汎用レジスタは2つです。</p>
<h2 id="命令セット">命令セット</h2>
<p>命令を作成するために各bitをどのように使うかを決定します。</p>
<p>今回作成した4bitCPUは命令長が4bitです。そのため、今回の設計ではオペランドに1bit、レジスタに1bit割り振りました。よって命令と汎用レジスタ数はそれぞれ2個（\(2^1\)）ずつとなっています。使用出来る命令はADDとLDIです。</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>命令機能</th>
</tr>
</thead>
<tbody>
<tr>
<td>ADD Rdest</td>
<td>Rdest &lt;- R0 + R1</td>
</tr>
<tr>
<td>LDI Rdest, imm2</td>
<td>Rdest &lt;- imm2</td>
</tr>
</tbody>
</table>
<p>ADD命令はレジスタ同士を加算し、レジスタに書き戻します。オペコードは0で、オペランドに書き込み先レジスタ（Rdest）を指定します。普通のCPUであればRdestだけでなくRsrcも指定しますが今回はレジスタが2つしかないので省略しています。</p>
<p>LDI命令は1~3の整数値をレジスタに書き込みます。オペコードが1でオペランドに書き込み先レジスタ（Rdest）と即値を取ります。即値は2bitなので1~3を指定することが出来ます。</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>バイナリ表記</th>
</tr>
</thead>
<tbody>
<tr>
<td>ADD R0</td>
<td>0 0 X X</td>
</tr>
<tr>
<td>LDI R1, 2</td>
<td>1 1 1 0</td>
</tr>
</tbody>
</table>
<p>命令の表記例です。Xは未使用を表します。</p>
<p>bitの割り振りとしてはオペコードを2bitにして即値を1bitにするほうが実行できる命令の数が増え、汎用性の高いCPUを作ることが出来ましたが実装を簡略化するために今回のような設計にしました。</p>
<h2 id="組み合わせ回路">組み合わせ回路</h2>
<p>CPUは沢山の<strong>組み合わせ回路</strong>で構成されます。組み合わせ回路とは<strong>AND回路</strong>や<strong>OR回路</strong>、<strong>NOT回路</strong>などや、これらを組み合わせて作ることが出来る回路のことです。
例えばAND回路、OR回路、NOT回路を組み合わせることで半加算器を作ることができ、半加算器2つとOR回路を組み合わせることで全加算器を作ることが出来ます。<br>
マインクラフトにはレッドストーン回路と呼ばれるものがあります。これを用いることで組み合わせ回路を作ることが出来ます。
組み合わせ回路を作ることができればCPUを作ることが出来るわけです。</p>
<figure class="center">
    <img src="/images/4bitcpu/AND.png"
         alt="image" width="500"/> <figcaption>
            <p>AND回路</p>
        </figcaption>
</figure>

<figure class="center">
    <img src="/images/4bitcpu/OR.png"
         alt="image" width="500"/> <figcaption>
            <p>OR回路</p>
        </figcaption>
</figure>

<h2 id="回路">回路</h2>
<p>先ほど決めた命令にしたがって計算できるように回路を作成します。</p>
<p>回路の実装は以下のようになりました。
先ほど説明した原始的なCPUと異なる点として、実装を簡単にするためにプログラムカウンタの代わりにシフトレジスタを使いました。また命令が2つしかないのでALUの代わりに全加算器を用い、セレクタで命令を判定しています。  配線は白がクロック、赤がリセットです。命令メモリにはレバーで命令を手打ちします。</p>
<p>回路はクロックに同期して命令メモリの命令を順番に実行します。黄色い枠のセレクタは命令のオペランドで書き込む値の選択を行い、水色の枠のセレクタは書き込み先レジスタを選択します。</p>
<figure class="center">
    <img src="/images/4bitcpu/kairo.png"
         alt="image"/> <figcaption>
            <p>4bitCPU</p>
        </figcaption>
</figure>

<p>さいごに実際に計算を行います。</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>バイナリ表記</th>
<th>R0（予測値）</th>
<th>R1（予測値）</th>
</tr>
</thead>
<tbody>
<tr>
<td>LDI R0, 01</td>
<td>1001</td>
<td>0001</td>
<td>0000</td>
</tr>
<tr>
<td>LDI R1, 10</td>
<td>1110</td>
<td>0001</td>
<td>0010</td>
</tr>
<tr>
<td>ADD R0</td>
<td>00XX</td>
<td>0011</td>
<td>0010</td>
</tr>
<tr>
<td>LDI R2, 11</td>
<td>1111</td>
<td>0011</td>
<td>0011</td>
</tr>
<tr>
<td>ADD R0</td>
<td>00XX</td>
<td>0110</td>
<td>0011</td>
</tr>
<tr>
<td>ADD R0</td>
<td>00XX</td>
<td>1001</td>
<td>0011</td>
</tr>
</tbody>
</table>
<p>左の4つの明かりがR0、右の4つのあかりがR1です。明かりがついているときが1で消えているときが0に対応します。
正しく計算が行われていることがわかると思います。</p>
<figure class="center">
    <img src="/images/4bitcpu/reg.gif"
         alt="image"/> <figcaption>
            <p>register</p>
        </figcaption>
</figure>

<h1 id="おわりに">おわりに</h1>
<p>今回作成したCPUは非常に単純なものでしたが実際に計算を行うことが出来ました。回路の動作が目に見える形で実行され計算が行われるのは見ていて面白かったです。</p>
<p>CPUに興味の湧いた方や気になる方が入れば下記のサイト上で簡単なCPUが作れるみたいなので遊んでみるといいと思います。</p>
<ul>
<li><a href="http://nandgame.com/">http://nandgame.com/</a></li>
</ul>
<h1 id="参考記事">参考記事</h1>
<ul>
<li><a href="https://w.atwiki.jp/minecraft/pages/26.html">https://w.atwiki.jp/minecraft/pages/26.html</a></li>
</ul>
]]></content></item></channel></rss>